using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.Events;

/// <summary>
/// Chunks are squares that cover the entire render area and generate 
/// interactable game objects
/// </summary>
public class Chunk : MonoBehaviour
{
    public Vector2Int AbsoluteChunkIndex { get; private set; }
    private bool _isInitialized = false;
    // Magnets generated by the chunk
    private List<GameObject> _magnets;

    [SerializeField] private GameObject _magnetPrefab;

    private int _minNumMagnets = 0;
    private int _maxNumMagnets = 3;
    // private int _blockResolution = 8;

    public static event Action<List<GameObject>> OnAddMagnets;

    public void InitializeTerrain(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate terrain based on seed, chunk size and location, and number of terrains per chunk (can be a randomly generated amount too)
        AbsoluteChunkIndex = absoluteChunkIndex;
        // Set the scale of the chunk so the background size is updated
        transform.localScale = new Vector3(chunkSize, chunkSize, 0);
        _magnets = new List<GameObject>();
    }

    public List<GameObject> InitializeNewEntities(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate new entites based on seed, chunk size, location, and number of entities per chunk
        // Set the scale of the chunk so the background size is updated
        // transform.localScale = new Vector3(chunkSize, chunkSize, 0);

        // Random object with seed to generate same chunk given same seed
        var seed = 69420;
        System.Random rnd = new System.Random(seed + pairFunction(absoluteChunkIndex.x, absoluteChunkIndex.y*1000));

        // Decide how many magnets to spawn in this chunk
        int numMagnets = rnd.Next(_minNumMagnets, _maxNumMagnets + 1);
        numMagnets = 2;
        for (int i = 0; i < numMagnets; ++i)
        {
            // position of the magnet relative to the center of the chunk
            var magnetRelativePos = new Vector3(
                (float) (chunkSize * rnd.NextDouble() -chunkSize / 2),
                (float) (chunkSize * rnd.NextDouble() -chunkSize / 2),
                transform.position.z - 1 // offset magnet to prevent sprite overlap
            );
            _magnets.Add(
                Instantiate(
                    _magnetPrefab, 
                    transform.position + magnetRelativePos, 
                    Quaternion.identity
                )
            );
        }
        
        OnAddMagnets.Invoke(_magnets); 

        return _magnets;
    }

    // Gaurantees to return a unique integer number for each (i, j) pair
    private int pairFunction(int i, int j)
    {
        return (i + j) * (i + j + 1) / 2 + j;
    }
}
