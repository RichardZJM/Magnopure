using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.Tilemaps;
using UnityEngine.Events;

/// <summary>
/// Chunks are squares that cover the entire render area and generate 
/// interactable game objects
/// </summary>
public class Chunk : MonoBehaviour
{
    public Vector2Int AbsoluteChunkIndex { get; private set; }
    // Magnets generated by the chunk
    private List<GameObject> _magnets;
 
    [SerializeField] private GameObject _magnetPrefab;
    private Tilemap _tilemap;
    [SerializeField] private Tile _tile;

    private int _minNumMagnets = 0;
    private int _maxNumMagnets = 3;
    private int _seed = 69420;
    private int _unitResolution = 4;        // How many blocks we have per unit
    private float _terrainCutoff = 0.54f;
    private Vector2 _perlinScaling = new Vector2(0.02f,0.02f);


    public static event Action<List<GameObject>> OnAddMagnets;

    public void InitializeTerrain(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate terrain based on seed, chunk size and location, and number of terrains per chunk (can be a randomly generated amount too)
        AbsoluteChunkIndex = absoluteChunkIndex;
        _tilemap = GameObject.FindGameObjectsWithTag("tilemap")[0].GetComponent<Tilemap>();
        // Set the scale of the chunk so the background size is updated
        transform.localScale = new Vector3(chunkSize, chunkSize, 0);
        _magnets = new List<GameObject>();
        
        int blockCount = (int) chunkSize * _unitResolution;
        Vector2 chunkCorner = new Vector2( (absoluteChunkIndex.x -0.5f) *  blockCount, (absoluteChunkIndex.y -0.5f)*  blockCount);
        for (int i = 0; i < blockCount; i++){
            int x = (int)chunkCorner.x + i;
            for (int j = 0; j< blockCount; j++){
                int y = (int)chunkCorner.y + j;
                if(PerlinComponent(new Vector2(x,y)) > _terrainCutoff) _tilemap.SetTile(new Vector3Int(x,y,0), _tile);
            }   
        }
        
    }

    public void KillTerrain(float chunkSize, Vector2Int absoluteChunkIndex) {
        int blockCount = (int) chunkSize * _unitResolution;
        Vector2 chunkCorner = new Vector2( (absoluteChunkIndex.x -0.5f) *  blockCount, (absoluteChunkIndex.y -0.5f)*  blockCount);
        for (int i = 0; i < blockCount; i++){
            int x = (int)chunkCorner.x + i;
            for (int j = 0; j< blockCount; j++){
                int y = (int)chunkCorner.y + j;
                _tilemap.SetTile(new Vector3Int(x,y,0), null);
            }   
        }
        
    }

    public List<GameObject> InitializeNewEntities(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate new entites based on seed, chunk size, location, and number of entities per chunk
        // Set the scale of the chunk so the background size is updated
        // transform.localScale = new Vector3(chunkSize, chunkSize, 0);

        // Random object with seed to generate same chunk given same seed
        System.Random rnd = new System.Random(_seed + PairFunction(absoluteChunkIndex.x, absoluteChunkIndex.y*1000));

        // Decide how many magnets to spawn in this chunk
        int numMagnets = rnd.Next(_minNumMagnets, _maxNumMagnets + 1);
        numMagnets = 2;
        for (int i = 0; i < numMagnets; ++i)
        {
            // position of the magnet relative to the center of the chunk
            var magnetRelativePos = new Vector3(
                (float) (chunkSize * rnd.NextDouble() -chunkSize / 2),
                (float) (chunkSize * rnd.NextDouble() -chunkSize / 2),
                transform.position.z - 1 // offset magnet to prevent sprite overlap
            );
            _magnets.Add(
                Instantiate(
                    _magnetPrefab, 
                    transform.position + magnetRelativePos, 
                    Quaternion.identity
                )
            );
        }
        
        OnAddMagnets.Invoke(_magnets); 

        return _magnets;
    }

    // Gaurantees to return a unique integer number for each (i, j) pair
    private int PairFunction(int i, int j)
    {
        return (i + j) * (i + j + 1) / 2 + j;
    }

    private float PerlinComponent(Vector2 blockCoordinate){
        Vector2 perlinCoordinate = blockCoordinate * _perlinScaling;
        float perlinValue = Mathf.PerlinNoise(perlinCoordinate.x + _seed,perlinCoordinate.y + _seed);
        // Debug.Log(perlinValue);
        return perlinValue;
    }
}


