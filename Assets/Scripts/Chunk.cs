using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.Events;

/// <summary>
/// Chunks are squares that cover the entire render area and generate 
/// interactable game objects
/// </summary>
public class Chunk : MonoBehaviour
{
    public Vector2Int AbsoluteChunkIndex { get; private set; }
    private bool _isInitialized = false;
    // Magnets generated by the chunk
    private List<GameObject> _magnets;

    [SerializeField] private GameObject _magnetPrefab;

    private int _minNumMagnets = 0;
    private int _maxNumMagnets = 3;
    // private int _blockResolution = 8;

    public static event Action<List<GameObject>> OnAddMagnets;

    public void InitializeTerrain(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate terrain based on seed, chunk size and location, and number of terrains per chunk (can be a randomly generated amount too)
        AbsoluteChunkIndex = absoluteChunkIndex;
        // Set the scale of the chunk so the background size is updated
        transform.localScale = new Vector3(chunkSize, chunkSize, 0);
        _magnets = new List<GameObject>();
    }

    public List<GameObject> InitializeNewEntities(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate new entites based on seed, chunk size, location, and number of entities per chunk
        // Set the scale of the chunk so the background size is updated
        // transform.localScale = new Vector3(chunkSize, chunkSize, 0);

        // Random object with seed to generate same chunk given same seed
        System.Random rnd = new System.Random(6942 + absoluteChunkIndex.x + absoluteChunkIndex.y*1000);

        // Decide how many magnets to spawn in this chunk
        int numMagnets = rnd.Next(_minNumMagnets, _maxNumMagnets + 1);
        numMagnets = 0;
        for (int i = 0; i < numMagnets; ++i)
        {
            // position of the magnet relative to the center of the chunk
            var magnetRelativePos = new Vector3(
                (float) (chunkSize * rnd.NextDouble() -chunkSize / 2),
                (float) (chunkSize * rnd.NextDouble() -chunkSize / 2),
                transform.position.z - 1 // offset magnet to prevent sprite overlap
            );
            _magnets.Add(
                Instantiate(
                    _magnetPrefab, 
                    transform.position + magnetRelativePos, 
                    Quaternion.identity
                )
            );
        }
        
        OnAddMagnets.Invoke(_magnets); 

        return _magnets;
    }

    // static string HashString(string text, string salt = "")
    // {
    //     if (String.IsNullOrEmpty(text))
    //     {
    //         return String.Empty;
    //     }
        
    //     // Uses SHA256 to create the hash
    //     using (var sha = new System.Security.Cryptography.SHA256Managed())
    //     {
    //         // Convert the string to a byte array first, to be processed
    //         byte[] textBytes = System.Text.Encoding.UTF8.GetBytes(text + salt);
    //         byte[] hashBytes = sha.ComputeHash(textBytes);
            
    //         // Convert back to a string, removing the '-' that BitConverter adds
    //         string hash = BitConverter
    //             .ToString(hashBytes)
    //             .Replace("-", String.Empty);

    //         return hash;
    //     }
    // }
}
