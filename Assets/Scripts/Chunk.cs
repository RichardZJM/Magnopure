using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.Events;

/// <summary>
/// Chunks are squares that cover the entire render area and generate 
/// interactable game objects
/// </summary>
public class Chunk : MonoBehaviour
{
    // Side length of the chunk
    private float _size;
    public Vector2Int AbsoluteChunkIndex { get; private set; }
    private bool _isInitialized = false;
    // Magnets generated by the chunk
    private List<GameObject> _magnets = new List<GameObject>();

    [SerializeField] private GameObject _magnetPrefab;

    private int _minNumMagnets = 0;
    private int _maxNumMagnets = 3;
    // private int _blockResolution = 8;


    public static event Action<List<GameObject>> OnAddMagnets;

    public void InitializeNew(float chunkSize, Vector2Int absoluteChunkIndex)
    {
        if (_isInitialized)
        {
            return;
        }
        
        _isInitialized = true;
        _size = chunkSize;

        _magnets = new List<GameObject>();
    }

    public void Start()
    {
        // Set the scale of the chunk so the background size is updated
        transform.localScale = new Vector3(_size, _size, 0);


        // // Decide how many magnets to spawn in this chunk
        // int numMagnets = Random.Range(_minNumMagnets, _maxNumMagnets + 1);
        // for (int i = 0; i < numMagnets; ++i)
        // {
        //     // position of the magnet relative to the center of the chunk
        //     var magnetRelativePos = new Vector3(
        //         Random.Range(-_size / 2, _size / 2),
        //         Random.Range(-_size / 2, _size / 2),
        //         transform.position.z - 1 // offset magnet to prevent sprite overlap
        //     );
        //     _magnets.Add(
        //         Instantiate(
        //             _magnetPrefab, 
        //             transform.position + magnetRelativePos, 
        //             Quaternion.identity
        //         )
        //     );
        // }
        //onAddMagnets.Invoke(_magnets);
    }

    public void InitializeTerrain(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate terrain based on seed, chunk size and location, and number of terrains per chunk (can be a randomly generated amount too)
        AbsoluteChunkIndex = absoluteChunkIndex;
    }

    public void InitializeNewEntities(float chunkSize, Vector2Int absoluteChunkIndex) {
        // Generate new entites based on seed, chunk size, location, and number of entities per chunk
        // Set the scale of the chunk so the background size is updated
        // transform.localScale = new Vector3(_size, _size, 0);

        // Random object with seed to generate same chunk given same seed
        System.Random rnd = new System.Random(6942 + absoluteChunkIndex.x);

        // Decide how many magnets to spawn in this chunk
        int numMagnets = rnd.Next(_minNumMagnets, _maxNumMagnets + 1);
        numMagnets = 5;
        for (int i = 0; i < numMagnets; ++i)
        {
            // position of the magnet relative to the center of the chunk
            var magnetRelativePos = new Vector3(
                _size * (float) rnd.NextDouble() -_size / 2,
                _size * (float) rnd.NextDouble() -_size / 2,
                transform.position.z - 1 // offset magnet to prevent sprite overlap
            );
            var gameObject = Instantiate(
                    _magnetPrefab, 
                    transform.position + magnetRelativePos, 
                    Quaternion.identity
                );
            Debug.Log(gameObject);
            _magnets.Add(
                gameObject
            );
            Debug.Log("Nodada");
        }
        
        OnAddMagnets.Invoke(_magnets); 
    }

    // static string HashString(string text, string salt = "")
    // {
    //     if (String.IsNullOrEmpty(text))
    //     {
    //         return String.Empty;
    //     }
        
    //     // Uses SHA256 to create the hash
    //     using (var sha = new System.Security.Cryptography.SHA256Managed())
    //     {
    //         // Convert the string to a byte array first, to be processed
    //         byte[] textBytes = System.Text.Encoding.UTF8.GetBytes(text + salt);
    //         byte[] hashBytes = sha.ComputeHash(textBytes);
            
    //         // Convert back to a string, removing the '-' that BitConverter adds
    //         string hash = BitConverter
    //             .ToString(hashBytes)
    //             .Replace("-", String.Empty);

    //         return hash;
    //     }
    // }
}
